from typing import ClassVar, overload

class CompoundOperation(Operation): ...
    def __getitem__(self, arg0: int) -> Operation: ...
    def __init__(self, nq: int, ops: list[Operation]) -> None: ...
    def __len__(self) -> int: ...
    def acts_on(self, arg0: int) -> bool: ...
    def clone(self) -> Operation: ...
    def empty(self) -> bool: ...
    def equals(self, other: Operation, p1: Permutation, p2: Permutation) -> bool: ...
    def get_used_qubits(self) -> set[int]: ...
    def is_compound_operation(self) -> bool: ...
    def is_non_unitary_operation(self) -> bool: ...
    def set_n_qubits(self, arg0: int) -> None: ...
    def size(self) -> int: ...
    def to_open_qasm(self, arg0: list[tuple[str, str]], arg1: list[tuple[str, str]]) -> str: ...

class Control:
    @overload
    def __init__(self, qubit: int) -> None: ...
    @overload
    def __init__(self, qubit: int, type: ControlType) -> None: ...
    @property
    def control_type(self) -> ...: ...
    @control_type.setter
    def control_type(self, arg0: ControlType) -> None: ...
    @property
    def qubit(self) -> int: ...
    @qubit.setter
    def qubit(self, arg0: int) -> None: ...

class ControlType:
    __members__: ClassVar[dict[ControlType, str]]  # readonly
    Neg: ClassVar[ControlType]  # value = <ControlType.Neg: 0>
    Pos: ClassVar[ControlType]  # value = <ControlType.Pos: 1>
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Expression: ...

    __hash__: ClassVar[None] = None
    constant: float
    @overload
    def __add__(self, arg0: Expression) -> Expression: ...
    @overload
    def __add__(self, arg0: Term) -> Expression: ...
    @overload
    def __add__(self, arg0: float) -> Expression: ...
    def __eq__(self, arg0: Expression) -> bool: ...
    def __getitem__(self, arg0: int) -> Term: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, terms: list[Term], constant: float = 0.0) -> None: ...
    @overload
    def __init__(self, term: Term, constant: float = 0.0) -> None: ...
    @overload
    def __init__(self, constant: float) -> None: ...
    def __iter__(self) -> Iterator: ...
    def __len__(self) -> int: ...
    def __mul__(self, arg0: float) -> Expression: ...
    @overload
    def __radd__(self, arg0: Term) -> Expression: ...
    @overload
    def __radd__(self, arg0: float) -> Expression: ...
    def __rmul__(self, arg0: float) -> Expression: ...
    @overload
    def __rsub__(self, arg0: Term) -> Expression: ...
    @overload
    def __rsub__(self, arg0: float) -> Expression: ...
    def __rtruediv__(self, arg0: float) -> Expression: ...
    @overload
    def __sub__(self, arg0: Expression) -> Expression: ...
    @overload
    def __sub__(self, arg0: Term) -> Expression: ...
    @overload
    def __sub__(self, arg0: float) -> Expression: ...
    def __truediv__(self, arg0: float) -> Expression: ...
    def evaluate(self, assignment: dict[Variable, float]) -> float: ...
    def is_constant(self) -> bool: ...
    def is_zero(self) -> bool: ...
    def num_terms(self) -> int: ...
    @property
    def terms(self) -> list[Term]: ...

class NonUnitaryOperation(Operation): ...

    @overload
    def __init__(self, nq: int, targets: list[int], classics: list[int]) -> None: ...
    @overload
    def __init__(self, nq: int, target: int, classic: int) -> None: ...
    @overload
    def __init__(self, nq: int, targets: list[int], op_type: OpType) -> None: ...
    def acts_on(self, arg0: int) -> bool: ...
    def clone(self) -> Operation: ...
    @overload
    def equals(self, arg0: Operation, p1: Permutation, p2: Permutation) -> bool: ...
    @overload
    def equals(self, arg0: Operation) -> bool: ...
    def get_used_qubits(self) -> set[int]: ...
    def is_non_unitary_operation(self) -> bool: ...
    def is_unitary(self) -> bool: ...
    def to_open_qasm(self, arg0: list[tuple[str, str]], arg1: list[tuple[str, str]]) -> str: ...
    @property
    def classics(self) -> list[int]: ...
    @property
    def n_targets(self) -> int: ...
    @property
    def targets(self) -> list[int]: ...
    @targets.setter
    def targets(self, arg1: list[int]) -> None: ...

class OpType: ...

    __members__: ClassVar[dict[OpType, str]]  # readonly
    barrier: ClassVar[OpType]  # value = <OpType.barrier: 3>
    classiccontrolled: ClassVar[OpType]  # value = <OpType.classiccontrolled: 38>
    compound: ClassVar[OpType]  # value = <OpType.compound: 34>
    dcx: ClassVar[OpType]  # value = <OpType.dcx: 26>
    ecr: ClassVar[OpType]  # value = <OpType.ecr: 27>
    gphase: ClassVar[OpType]  # value = <OpType.gphase: 1>
    h: ClassVar[OpType]  # value = <OpType.h: 4>
    i: ClassVar[OpType]  # value = <OpType.i: 2>
    iswap: ClassVar[OpType]  # value = <OpType.iswap: 23>
    measure: ClassVar[OpType]  # value = <OpType.measure: 35>
    none: ClassVar[OpType]  # value = <OpType.none: 0>
    peres: ClassVar[OpType]  # value = <OpType.peres: 24>
    peresdag: ClassVar[OpType]  # value = <OpType.peresdag: 25>
    phase: ClassVar[OpType]  # value = <OpType.phase: 16>
    reset: ClassVar[OpType]  # value = <OpType.reset: 36>
    rx: ClassVar[OpType]  # value = <OpType.rx: 19>
    rxx: ClassVar[OpType]  # value = <OpType.rxx: 28>
    ry: ClassVar[OpType]  # value = <OpType.ry: 20>
    ryy: ClassVar[OpType]  # value = <OpType.ryy: 29>
    rz: ClassVar[OpType]  # value = <OpType.rz: 21>
    rzx: ClassVar[OpType]  # value = <OpType.rzx: 31>
    rzz: ClassVar[OpType]  # value = <OpType.rzz: 30>
    s: ClassVar[OpType]  # value = <OpType.s: 8>
    sdag: ClassVar[OpType]  # value = <OpType.sdag: 9>
    swap: ClassVar[OpType]  # value = <OpType.swap: 22>
    sx: ClassVar[OpType]  # value = <OpType.sx: 17>
    sxdag: ClassVar[OpType]  # value = <OpType.sxdag: 18>
    t: ClassVar[OpType]  # value = <OpType.t: 10>
    tdag: ClassVar[OpType]  # value = <OpType.tdag: 11>
    teleportation: ClassVar[OpType]  # value = <OpType.teleportation: 37>
    u2: ClassVar[OpType]  # value = <OpType.u2: 15>
    u3: ClassVar[OpType]  # value = <OpType.u3: 14>
    v: ClassVar[OpType]  # value = <OpType.v: 12>
    vdag: ClassVar[OpType]  # value = <OpType.vdag: 13>
    x: ClassVar[OpType]  # value = <OpType.x: 5>
    xx_minus_yy: ClassVar[OpType]  # value = <OpType.xx_minus_yy: 32>
    xx_plus_yy: ClassVar[OpType]  # value = <OpType.xx_plus_yy: 33>
    y: ClassVar[OpType]  # value = <OpType.y: 6>
    z: ClassVar[OpType]  # value = <OpType.z: 7>
    @staticmethod
    def name(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def value(self) -> int: ...

class Operation: ...

    controls: set[Control]
    gate: ...
    n_qubits: int
    targets: list[int]
    def acts_on(self, qubit: int) -> bool: ...
    def get_starting_qubit(self) -> int: ...
    def get_used_qubits(self) -> set[int]: ...
    def is_classic_controlled_operation(self) -> bool: ...
    def is_compound_operation(self) -> bool: ...
    def is_controlled(self) -> bool: ...
    def is_non_unitary_operation(self) -> bool: ...
    def is_standard_operation(self) -> bool: ...
    def is_symbolic_operation(self) -> bool: ...
    def is_unitary(self) -> bool: ...
    @property
    def n_controls(self) -> int: ...
    @property
    def n_targets(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self) -> None: ...

class Permutation: ...

    def __getitem__(self, arg0: int) -> int: ...
    def __iter__(self) -> Iterator: ...
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    @overload
    def apply(self, arg0: set[Control]) -> set[Control]: ...
    @overload
    def apply(self, arg0: list[int]) -> list[int]: ...

class QuantumComputation: ...

    gphase: float
    name: str
    def __getitem__(self, arg0: int) -> ...: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nq: int) -> None: ...
    @overload
    def __init__(self, filename: str) -> None: ...
    def __len__(self) -> int: ...
    def add_ancillary_register(self, n: int, name: str = "") -> None: ...
    def add_classical_bit_register(self, n: int, name: str = "") -> None: ...
    def add_qubit_register(self, n: int, name: str = "") -> None: ...
    def add_variable(self, var: ... | double | float) -> None: ...
    def add_variables(self, vars: list[... | double | float]) -> None: ...
    def append_operation(self, op: OpType) -> None: ...
    @overload
    def barrier(self, q: int) -> None: ...
    @overload
    def barrier(self, qs: list[int]) -> None: ...
    @overload
    def classic_controlled(self, op: OpType, q: int, c: tuple[int, int], t: int, params: list[float]) -> None: ...
    @overload
    def classic_controlled(
        self, op: OpType, q: int, ctrl: Control, c: tuple[int, int], t: int, params: list[float]
    ) -> None: ...
    def clone(self) -> QuantumComputation: ...
    @overload
    def dcx(self, q1: int, q2: int) -> None: ...
    @overload
    def dcx(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def dcx(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def dump(self, filename: str) -> None: ...
    @overload
    def dump(self, filename: str, format: str) -> None: ...
    @overload
    def ecr(self, q1: int, q2: int) -> None: ...
    @overload
    def ecr(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def ecr(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def from_file(self, filename: str) -> None: ...
    @overload
    def from_file(self, filename: str, format: str) -> None: ...
    def get_variables(self) -> set[...]: ...
    @overload
    def h(self, q: int) -> None: ...
    @overload
    def h(self, q: int, ctrl: Control) -> None: ...
    @overload
    def h(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def i(self, q: int) -> None: ...
    @overload
    def i(self, q: int, ctrl: Control) -> None: ...
    @overload
    def i(self, q: int, controls: set[Control]) -> None: ...
    def initialize_io_mapping(self) -> None: ...
    def instantiate(self, assignment: dict[..., float]) -> None: ...
    def is_variable_free(self) -> bool: ...
    @overload
    def iswap(self, q1: int, q2: int) -> None: ...
    @overload
    def iswap(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def iswap(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def measure(self, q: int, c: int) -> None: ...
    @overload
    def measure(self, q: int, c: tuple[str, int]) -> None: ...
    @overload
    def measure(self, qs: list[int], cs: list[int]) -> None: ...
    @overload
    def peres(self, q1: int, q2: int) -> None: ...
    @overload
    def peres(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def peres(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def peresdag(self, q1: int, q2: int) -> None: ...
    @overload
    def peresdag(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def peresdag(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def phase(self, q: int, lambda_: float) -> None: ...
    @overload
    def phase(self, q: int, ctrl: Control, lambda_: float) -> None: ...
    @overload
    def phase(self, q: int, controls: set[Control], lambda_: float) -> None: ...
    @overload
    def reset(self, q: int) -> None: ...
    @overload
    def reset(self, qs: list[int]) -> None: ...
    @overload
    def rx(self, q: int, theta: float) -> None: ...
    @overload
    def rx(self, q: int, ctrl: Control, theta: float) -> None: ...
    @overload
    def rx(self, q: int, controls: set[Control], theta: float) -> None: ...
    @overload
    def rxx(self, q1: int, q2: int, phi: float) -> None: ...
    @overload
    def rxx(self, q1: int, q2: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def rxx(self, q1: int, q2: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def ry(self, q: int, theta: float) -> None: ...
    @overload
    def ry(self, q: int, ctrl: Control, theta: float) -> None: ...
    @overload
    def ry(self, q: int, controls: set[Control], theta: float) -> None: ...
    @overload
    def ryy(self, q1: int, q2: int, phi: float) -> None: ...
    @overload
    def ryy(self, q1: int, q2: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def ryy(self, q1: int, q2: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def rz(self, q: int, phi: float) -> None: ...
    @overload
    def rz(self, q: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def rz(self, q: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def rzx(self, q1: int, q2: int, phi: float) -> None: ...
    @overload
    def rzx(self, q1: int, q2: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def rzx(self, q1: int, q2: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def rzz(self, q1: int, q2: int, phi: float) -> None: ...
    @overload
    def rzz(self, q1: int, q2: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def rzz(self, q1: int, q2: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def s(self, q: int) -> None: ...
    @overload
    def s(self, q: int, ctrl: Control) -> None: ...
    @overload
    def s(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def sdag(self, q: int) -> None: ...
    @overload
    def sdag(self, q: int, ctrl: Control) -> None: ...
    @overload
    def sdag(self, q: int, controls: set[Control]) -> None: ...
    def set_logical_qubit_ancillary(self, q: int) -> None: ...
    @overload
    def swap(self, q1: int, q2: int) -> None: ...
    @overload
    def swap(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def swap(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def sx(self, q: int) -> None: ...
    @overload
    def sx(self, q: int, ctrl: Control) -> None: ...
    @overload
    def sx(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def sxdag(self, q: int) -> None: ...
    @overload
    def sxdag(self, q: int, ctrl: Control) -> None: ...
    @overload
    def sxdag(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def t(self, q: int) -> None: ...
    @overload
    def t(self, q: int, ctrl: Control) -> None: ...
    @overload
    def t(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def tdag(self, q: int) -> None: ...
    @overload
    def tdag(self, q: int, ctrl: Control) -> None: ...
    @overload
    def tdag(self, q: int, controls: set[Control]) -> None: ...
    def to_open_qasm(self) -> str: ...
    @overload
    def u2(self, q: int, phi: float, lambda_: float) -> None: ...
    @overload
    def u2(self, q: int, ctrl: Control, phi: float, lambda_: float) -> None: ...
    @overload
    def u2(self, q: int, controls: set[Control], phi: float, lambda_: float) -> None: ...
    @overload
    def u3(self, q: int, theta: float, phi: float, lambda_: float) -> None: ...
    @overload
    def u3(self, q: int, ctrl: Control, theta: float, phi: float, lambda_: float) -> None: ...
    @overload
    def u3(self, q: int, controls: set[Control], theta: float, phi: float, lambda_: float) -> None: ...
    @overload
    def v(self, q: int) -> None: ...
    @overload
    def v(self, q: int, ctrl: Control) -> None: ...
    @overload
    def v(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def vdag(self, q: int) -> None: ...
    @overload
    def vdag(self, q: int, ctrl: Control) -> None: ...
    @overload
    def vdag(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def x(self, q: int) -> None: ...
    @overload
    def x(self, q: int, ctrl: Control) -> None: ...
    @overload
    def x(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def xx_minus_yy(self, q1: int, q2: int, phi: float, lambda_: float) -> None: ...
    @overload
    def xx_minus_yy(self, q1: int, q2: int, ctrl: Control, phi: float, lambda_: float) -> None: ...
    @overload
    def xx_minus_yy(self, q1: int, q2: int, controls: set[Control], phi: float, lambda_: float) -> None: ...
    @overload
    def xx_plus_yy(self, q1: int, q2: int, phi: float, lambda_: float) -> None: ...
    @overload
    def xx_plus_yy(self, q1: int, q2: int, ctrl: Control, phi: float, lambda_: float) -> None: ...
    @overload
    def xx_plus_yy(self, q1: int, q2: int, controls: set[Control], phi: float, lambda_: float) -> None: ...
    @overload
    def y(self, q: int) -> None: ...
    @overload
    def y(self, q: int, ctrl: Control) -> None: ...
    @overload
    def y(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def z(self, q: int) -> None: ...
    @overload
    def z(self, q: int, ctrl: Control) -> None: ...
    @overload
    def z(self, q: int, controls: set[Control]) -> None: ...
    @property
    def depth(self) -> int: ...
    @property
    def initial_layout(self) -> ...: ...
    @property
    def n_ancillae(self) -> int: ...
    @property
    def n_cbits(self) -> int: ...
    @property
    def n_individual_ops(self) -> int: ...
    @property
    def n_ops(self) -> int: ...
    @property
    def n_qubits(self) -> int: ...
    @property
    def n_qubits_without_ancillae(self) -> int: ...
    @property
    def n_single_qubit_ops(self) -> int: ...
    @property
    def output_permutation(self) -> ...: ...

class StandardOperation(Operation): ...

    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self, nq: int, target: int, op_type: OpType, params: list[float] = [], starting_qubit: int = 0
    ) -> None: ...
    @overload
    def __init__(
        self, nq: int, targets: list[int], op_type: OpType, params: list[float] = [], starting_qubit: int = 0
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        control: Control,
        target: int,
        op_type: OpType,
        params: list[float] = [],
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        control: Control,
        targets: list[int],
        op_type: OpType,
        params: list[float] = [],
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        target: int,
        op_type: OpType,
        params: list[float] = [],
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        targets: list[int],
        op_type: OpType,
        params: list[float] = [],
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(self, nq: int, controls: set[Control], target: int, starting_qubit: int = 0) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        target0: int,
        target1: int,
        op_type: OpType,
        params: list[float] = [],
        starting_qubit: int = 0,
    ) -> None: ...
    def clone(self) -> Operation: ...
    @overload
    def equals(self, arg0: Operation) -> bool: ...
    @overload
    def equals(self, arg0: Operation, arg1: ..., arg2: ...) -> bool: ...
    def is_standard_operation(self) -> bool: ...
    def to_open_qasm(self, arg0: list[tuple[str, str]], arg1: list[tuple[str, str]]) -> str: ...

class SymbolicOperation(Operation): ...

    @staticmethod
    def get_instantiated_operation(*args, **kwargs) -> StandardOperation: ...
    @staticmethod
    def instantiate(*args, **kwargs) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        target: int,
        op_type: OpType,
        params: list[... | double | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
        if params is None:
            params = []
    @overload
    def __init__(
        self,
        nq: int,
        targets: list[int],
        op_type: OpType,
        params: list[... | double | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
        if params is None:
            params = []
    @overload
    def __init__(
        self,
        nq: int,
        control: Control,
        target: int,
        op_type: OpType,
        params: list[... | double | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
        if params is None:
            params = []
    @overload
    def __init__(
        self,
        nq: int,
        control: Control,
        targets: list[int],
        op_type: OpType,
        params: list[... | double | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
        if params is None:
            params = []
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        target: int,
        op_type: OpType,
        params: list[... | double | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
        if params is None:
            params = []
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        targets: list[int],
        op_type: OpType,
        params: list[... | double | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
        if params is None:
            params = []
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        target0: int,
        target1: int,
        op_type: OpType,
        params: list[Expression | double | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
        if params is None:
            params = []
    def clone(self) -> Operation: ...
    @overload
    def equals(self, arg0: Operation, arg1: Permutation, arg2: Permutation) -> bool: ...
    @overload
    def equals(self, arg0: Operation) -> bool: ...
    def get_parameter(self, arg0: int) -> Expression | double | float: ...
    def get_parameters(self) -> list[Expression | double | float]: ...
    def is_standard_operation(self) -> bool: ...
    def is_symbolic_operation(self) -> bool: ...

class Term: ...

    @overload
    def __init__(self, coefficient: float, variable: Variable) -> None: ...
    @overload
    def __init__(self, variable: Variable) -> None: ...
    def __mul__(self, arg0: float) -> Term: ...
    def __rmul__(self, arg0: float) -> Term: ...
    def __rtruediv__(self, arg0: float) -> Term: ...
    def __truediv__(self, arg0: float) -> Term: ...
    def add_coefficient(self, coeff: float) -> None: ...
    def evaluate(self, assignment: dict[Variable, float]) -> float: ...
    def has_zero_coefficient(self) -> bool: ...
    @property
    def coefficient(self) -> float: ...
    @property
    def variable(self) -> Variable: ...

class Variable: ...

    __hash__: ClassVar[None] = None
    def __eq__(self, arg0: Variable) -> bool: ...
    def __gt__(self, arg0: Variable) -> bool: ...
    def __init__(self, name: str = "") -> None: ...
    def __lt__(self, arg0: Variable) -> bool: ...
    def __ne__(self, arg0: Variable) -> bool: ...
    @property
    def name(self) -> str: ...

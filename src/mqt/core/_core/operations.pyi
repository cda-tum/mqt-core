from typing import ClassVar, Iterator, overload

from .quantum_computation import OpType
from .symbolic import Expression, Variable

class ControlType:
    __members__: ClassVar[dict[ControlType, str]]  # readonly
    Neg: ClassVar[ControlType]  # value = <ControlType.Neg: 0>
    Pos: ClassVar[ControlType]  # value = <ControlType.Pos: 1>
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    def __init__(self, value: int) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def name(self) -> str: ...
    @property
    def value(self) -> int: ...

class Control:
    @overload
    def __init__(self, qubit: int) -> None: ...
    @overload
    def __init__(self, qubit: int, type_: ControlType) -> None: ...
    @property
    def control_type(self) -> ControlType: ...
    @control_type.setter
    def control_type(self, arg0: ControlType) -> None: ...
    @property
    def qubit(self) -> int: ...
    @qubit.setter
    def qubit(self, arg0: int) -> None: ...

class Operation:
    controls: set[Control]
    gate: OpType
    n_qubits: int
    targets: list[int]
    def acts_on(self, qubit: int) -> bool: ...
    def get_starting_qubit(self) -> int: ...
    def get_used_qubits(self) -> set[int]: ...
    def is_classic_controlled_operation(self) -> bool: ...
    def is_compound_operation(self) -> bool: ...
    def is_controlled(self) -> bool: ...
    def is_non_unitary_operation(self) -> bool: ...
    def is_standard_operation(self) -> bool: ...
    def is_symbolic_operation(self) -> bool: ...
    def is_unitary(self) -> bool: ...
    @property
    def n_controls(self) -> int: ...
    @property
    def n_targets(self) -> int: ...
    @property
    def name(self) -> str: ...
    @name.setter
    def name(self) -> None: ...

class CompoundOperation(Operation):
    def __getitem__(self, arg0: int) -> Operation: ...
    @overload
    def __init__(self, nq: int) -> None: ...
    @overload
    def __init__(self, nq: int, ops: list[Operation]) -> None: ...
    def __len__(self) -> int: ...
    def acts_on(self, arg0: int) -> bool: ...
    def clone(self) -> Operation: ...
    def empty(self) -> bool: ...
    def equals(self, other: Operation, p1: Permutation, p2: Permutation) -> bool: ...
    def get_used_qubits(self) -> set[int]: ...
    def is_compound_operation(self) -> bool: ...
    def is_non_unitary_operation(self) -> bool: ...
    def set_n_qubits(self, arg0: int) -> None: ...
    def size(self) -> int: ...
    def to_open_qasm(self, arg0: list[tuple[str, str]], arg1: list[tuple[str, str]]) -> str: ...
    def append_operation(self, op: Operation) -> None: ...

class NonUnitaryOperation(Operation):
    @overload
    def __init__(self, nq: int, targets: list[int], classics: list[int]) -> None: ...
    @overload
    def __init__(self, nq: int, target: int, classic: int) -> None: ...
    @overload
    def __init__(self, nq: int, targets: list[int], op_type: OpType) -> None: ...
    def acts_on(self, arg0: int) -> bool: ...
    def clone(self) -> Operation: ...
    @overload
    def equals(self, arg0: Operation, p1: Permutation, p2: Permutation) -> bool: ...
    @overload
    def equals(self, arg0: Operation) -> bool: ...
    def get_used_qubits(self) -> set[int]: ...
    def is_non_unitary_operation(self) -> bool: ...
    def is_unitary(self) -> bool: ...
    def to_open_qasm(self, arg0: list[tuple[str, str]], arg1: list[tuple[str, str]]) -> str: ...
    @property
    def classics(self) -> list[int]: ...
    @property
    def n_targets(self) -> int: ...
    @property
    def targets(self) -> list[int]: ...
    @targets.setter
    def targets(self, arg1: list[int]) -> None: ...

class Permutation:
    def __getitem__(self, arg0: int) -> int: ...
    def __iter__(self) -> Iterator[tuple[int, int]]: ...
    def __setitem__(self, arg0: int, arg1: int) -> None: ...
    def __init__(self, p: dict[int, int]) -> None: ...
    @overload
    def apply(self, arg0: set[Control]) -> set[Control]: ...
    @overload
    def apply(self, arg0: list[int]) -> list[int]: ...

class StandardOperation(Operation):
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nq: int, target: int, op_type: OpType, params: list[float], starting_qubit: int = 0) -> None: ...
    @overload
    def __init__(
        self, nq: int, targets: list[int], op_type: OpType, params: list[float], starting_qubit: int = 0
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        control: Control,
        target: int,
        op_type: OpType,
        params: list[float],
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        control: Control,
        targets: list[int],
        op_type: OpType,
        params: list[float],
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        target: int,
        op_type: OpType,
        params: list[float],
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        targets: list[int],
        op_type: OpType,
        params: list[float],
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(self, nq: int, controls: set[Control], target: int, starting_qubit: int = 0) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        target0: int,
        target1: int,
        op_type: OpType,
        params: list[float],
        starting_qubit: int = 0,
    ) -> None: ...
    def clone(self) -> Operation: ...
    @overload
    def equals(self, arg0: Operation) -> bool: ...
    @overload
    def equals(self, arg0: Operation, p1: Permutation, p2: Permutation) -> bool: ...
    def is_standard_operation(self) -> bool: ...
    def to_open_qasm(self, arg0: list[tuple[str, str]], arg1: list[tuple[str, str]]) -> str: ...

class SymbolicOperation(Operation):
    @staticmethod
    def get_instantiated_operation(assignment: dict[Variable, float]) -> StandardOperation: ...
    @staticmethod
    def instantiate(assignment: dict[Variable, float]) -> None: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        target: int,
        op_type: OpType,
        params: list[Expression | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        targets: list[int],
        op_type: OpType,
        params: list[Expression | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        control: Control,
        target: int,
        op_type: OpType,
        params: list[Expression | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        control: Control,
        targets: list[int],
        op_type: OpType,
        params: list[Expression | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        target: int,
        op_type: OpType,
        params: list[Expression | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        targets: list[int],
        op_type: OpType,
        params: list[Expression | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
    @overload
    def __init__(
        self,
        nq: int,
        controls: set[Control],
        target0: int,
        target1: int,
        op_type: OpType,
        params: list[Expression | float] | None = None,
        starting_qubit: int = 0,
    ) -> None: ...
    def clone(self) -> Operation: ...
    @overload
    def equals(self, arg0: Operation, arg1: Permutation, arg2: Permutation) -> bool: ...
    @overload
    def equals(self, arg0: Operation) -> bool: ...
    def get_parameter(self, arg0: int) -> Expression | float: ...
    def get_parameters(self) -> list[Expression | float]: ...
    def is_standard_operation(self) -> bool: ...
    def is_symbolic_operation(self) -> bool: ...

from collections.abc import Iterable, Mapping, MutableSequence, Sequence
from os import PathLike
from typing import overload

from .._compat.typing import Self
from .operations import (
    Control,
    Operation,
    OpType,
)
from .permutation import Permutation
from .symbolic import Expression, Variable

class QuantumComputation(MutableSequence[Operation]):
    # --------------------------------------------------------------------------
    #                               Constructors
    # --------------------------------------------------------------------------

    @overload
    def __init__(self: Self) -> None: ...
    @overload
    def __init__(self: Self, nq: int) -> None: ...
    @overload
    def __init__(self: Self, filename: PathLike[str]) -> None: ...

    # --------------------------------------------------------------------------
    #                          General Properties
    # --------------------------------------------------------------------------

    name: str
    global_phase: float

    @property
    def num_qubits(self: Self) -> int: ...
    @property
    def num_ancilla_qubits(self: Self) -> int: ...
    @property
    def num_qubits_without_ancilla_qubits(self: Self) -> int: ...
    @property
    def num_classical_bits(self: Self) -> int: ...
    @property
    def num_ops(self: Self) -> int: ...
    def num_single_qubit_ops(self: Self) -> int: ...
    @property
    def num_total_ops(self: Self) -> int: ...
    def depth(self: Self) -> int: ...
    def invert(self: Self) -> None: ...
    def to_operation(self: Self) -> Operation: ...

    # --------------------------------------------------------------------------
    #                 Mutable Sequence Interface
    # --------------------------------------------------------------------------

    def __len__(self: Self) -> int: ...
    @overload
    def __getitem__(self: Self, idx: int) -> Operation: ...
    @overload
    def __getitem__(self: Self, idx: slice) -> list[Operation]: ...
    @overload
    def __setitem__(self: Self, idx: int, op: Operation) -> None: ...
    @overload
    def __setitem__(self: Self, idx: slice, ops: Iterable[Operation]) -> None: ...
    @overload
    def __delitem__(self: Self, idx: int) -> None: ...
    @overload
    def __delitem__(self: Self, idx: slice) -> None: ...
    def insert(self: Self, idx: int, op: Operation) -> None: ...
    def append(self: Self, op: Operation) -> None: ...
    def reverse(self: Self) -> None: ...
    def clear(self: Self) -> None: ...

    # --------------------------------------------------------------------------
    #                          (Qu)Bit Registers
    # --------------------------------------------------------------------------

    def add_ancillary_register(self: Self, n: int, name: str = "q") -> None: ...
    def add_classical_register(self: Self, n: int, name: str = "c") -> None: ...
    def add_qubit_register(self: Self, n: int, name: str = "anc") -> None: ...
    def unify_quantum_registers(self: Self, name: str = "q") -> None: ...

    # --------------------------------------------------------------------------
    #                  Initial Layout and Output Permutation
    # --------------------------------------------------------------------------

    initial_layout: Permutation
    output_permutation: Permutation

    def initialize_io_mapping(self: Self) -> None: ...

    # --------------------------------------------------------------------------
    #                       Ancilla and Garbage Handling
    # --------------------------------------------------------------------------

    @property
    def ancillary(self: Self) -> list[bool]: ...
    def set_circuit_qubit_ancillary(self: Self, q: int) -> None: ...
    def is_circuit_qubit_ancillary(self: Self, q: int) -> bool: ...
    @property
    def garbage(self: Self) -> list[bool]: ...
    def set_circuit_qubit_garbage(self: Self, q: int) -> None: ...
    def is_circuit_qubit_garbage(self: Self, q: int) -> bool: ...

    # --------------------------------------------------------------------------
    #                        Symbolic Circuit Handling
    # --------------------------------------------------------------------------

    @property
    def variables(self: Self) -> set[Variable]: ...
    def add_variable(self: Self, var: Expression | float) -> None: ...
    def add_variables(self: Self, vars_: Sequence[Expression | float]) -> None: ...
    def is_variable_free(self: Self) -> bool: ...
    def instantiate(self: Self, assignment: Mapping[Variable, float]) -> None: ...

    # --------------------------------------------------------------------------
    #                             Output Handling
    # --------------------------------------------------------------------------

    def qasm_str(self: Self) -> str: ...
    def qasm(self: Self, filename: PathLike[str]) -> None: ...

    # --------------------------------------------------------------------------
    #                               Operations
    # --------------------------------------------------------------------------

    @overload
    def barrier(self: Self, q: int) -> None: ...
    @overload
    def barrier(self: Self, qs: Sequence[int]) -> None: ...
    @overload
    def classic_controlled(
        self: Self,
        op: OpType,
        target: int,
        classical_register: tuple[int, int],
        expected_value: int,
        params: Sequence[float],
    ) -> None: ...
    @overload
    def classic_controlled(
        self: Self,
        op: OpType,
        target: int,
        control: Control,
        classical_register: tuple[int, int],
        expected_value: int,
        params: Sequence[float],
    ) -> None: ...
    @overload
    def classic_controlled(
        self: Self,
        op: OpType,
        target: int,
        controls: set[Control],
        classical_register: tuple[int, int],
        expected_value: int,
        params: Sequence[float],
    ) -> None: ...
    @overload
    def dcx(self: Self, q1: int, q2: int) -> None: ...
    @overload
    def dcx(self: Self, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def dcx(self: Self, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def ecr(self: Self, q1: int, q2: int) -> None: ...
    @overload
    def ecr(self: Self, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def ecr(self: Self, controls: set[Control], q1: int, q2: int) -> None: ...
    def gphase(self: Self, phase: float) -> None: ...
    @overload
    def h(self: Self, q: int) -> None: ...
    @overload
    def h(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def h(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def i(self: Self, q: int) -> None: ...
    @overload
    def i(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def i(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def iswap(self: Self, q1: int, q2: int) -> None: ...
    @overload
    def iswap(self: Self, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def iswap(self: Self, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def measure(self: Self, q: int, c: int) -> None: ...
    @overload
    def measure(self: Self, q: int, c: tuple[str, int]) -> None: ...
    @overload
    def measure(self: Self, qs: Sequence[int], cs: Sequence[int]) -> None: ...
    @overload
    def peres(self: Self, q1: int, q2: int) -> None: ...
    @overload
    def peres(self: Self, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def peres(self: Self, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def peresdag(self: Self, q1: int, q2: int) -> None: ...
    @overload
    def peresdag(self: Self, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def peresdag(self: Self, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def phase(self: Self, lambda_: float, q: int) -> None: ...
    @overload
    def phase(self: Self, lambda_: float, ctrl: Control, q: int) -> None: ...
    @overload
    def phase(self: Self, lambda_: float, controls: set[Control], q: int) -> None: ...
    @overload
    def reset(self: Self, q: int) -> None: ...
    @overload
    def reset(self: Self, qs: Sequence[int]) -> None: ...
    @overload
    def rx(self: Self, theta: float, q: int) -> None: ...
    @overload
    def rx(self: Self, theta: float, ctrl: Control, q: int) -> None: ...
    @overload
    def rx(self: Self, theta: float, controls: set[Control], q: int) -> None: ...
    @overload
    def rxx(self: Self, phi: float, q1: int, q2: int) -> None: ...
    @overload
    def rxx(self: Self, phi: float, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def rxx(self: Self, phi: float, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def ry(self: Self, theta: float, q: int) -> None: ...
    @overload
    def ry(self: Self, theta: float, ctrl: Control, q: int) -> None: ...
    @overload
    def ry(self: Self, theta: float, controls: set[Control], q: int) -> None: ...
    @overload
    def ryy(self: Self, phi: float, q1: int, q2: int) -> None: ...
    @overload
    def ryy(self: Self, phi: float, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def ryy(self: Self, phi: float, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def rz(self: Self, phi: float, q: int) -> None: ...
    @overload
    def rz(self: Self, phi: float, ctrl: Control, q: int) -> None: ...
    @overload
    def rz(self: Self, phi: float, controls: set[Control], q: int) -> None: ...
    @overload
    def rzx(self: Self, phi: float, q1: int, q2: int) -> None: ...
    @overload
    def rzx(self: Self, phi: float, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def rzx(self: Self, phi: float, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def rzz(self: Self, phi: float, q1: int, q2: int) -> None: ...
    @overload
    def rzz(self: Self, phi: float, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def rzz(self: Self, phi: float, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def s(self: Self, q: int) -> None: ...
    @overload
    def s(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def s(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def sdag(self: Self, q: int) -> None: ...
    @overload
    def sdag(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def sdag(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def swap(self: Self, q1: int, q2: int) -> None: ...
    @overload
    def swap(self: Self, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def swap(self: Self, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def sx(self: Self, q: int) -> None: ...
    @overload
    def sx(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def sx(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def sxdag(self: Self, q: int) -> None: ...
    @overload
    def sxdag(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def sxdag(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def t(self: Self, q: int) -> None: ...
    @overload
    def t(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def t(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def tdag(self: Self, q: int) -> None: ...
    @overload
    def tdag(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def tdag(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def u2(self: Self, phi: float, lambda_: float, q: int) -> None: ...
    @overload
    def u2(self: Self, phi: float, lambda_: float, ctrl: Control, q: int) -> None: ...
    @overload
    def u2(self: Self, phi: float, lambda_: float, controls: set[Control], q: int) -> None: ...
    @overload
    def u3(self: Self, theta: float, phi: float, lambda_: float, q: int) -> None: ...
    @overload
    def u3(self: Self, theta: float, phi: float, lambda_: float, ctrl: Control, q: int) -> None: ...
    @overload
    def u3(self: Self, theta: float, phi: float, lambda_: float, controls: set[Control], q: int) -> None: ...
    @overload
    def v(self: Self, q: int) -> None: ...
    @overload
    def v(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def v(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def vdag(self: Self, q: int) -> None: ...
    @overload
    def vdag(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def vdag(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def x(self: Self, q: int) -> None: ...
    @overload
    def x(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def x(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def xx_minus_yy(self: Self, phi: float, lambda_: float, q1: int, q2: int) -> None: ...
    @overload
    def xx_minus_yy(self: Self, phi: float, lambda_: float, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def xx_minus_yy(self: Self, phi: float, lambda_: float, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def xx_plus_yy(self: Self, phi: float, lambda_: float, q1: int, q2: int) -> None: ...
    @overload
    def xx_plus_yy(self: Self, phi: float, lambda_: float, ctrl: Control, q1: int, q2: int) -> None: ...
    @overload
    def xx_plus_yy(self: Self, phi: float, lambda_: float, controls: set[Control], q1: int, q2: int) -> None: ...
    @overload
    def y(self: Self, q: int) -> None: ...
    @overload
    def y(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def y(self: Self, controls: set[Control], q: int) -> None: ...
    @overload
    def z(self: Self, q: int) -> None: ...
    @overload
    def z(self: Self, ctrl: Control, q: int) -> None: ...
    @overload
    def z(self: Self, controls: set[Control], q: int) -> None: ...

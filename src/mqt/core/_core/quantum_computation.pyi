from typing import ClassVar, overload

from .operations import Control, Operation, Permutation
from .symbolic import Expression, Variable

class OpType:
    __members__: ClassVar[dict[OpType, str]]  # readonly
    barrier: ClassVar[OpType]  # value = <OpType.barrier: 3>
    classiccontrolled: ClassVar[OpType]  # value = <OpType.classiccontrolled: 38>
    compound: ClassVar[OpType]  # value = <OpType.compound: 34>
    dcx: ClassVar[OpType]  # value = <OpType.dcx: 26>
    ecr: ClassVar[OpType]  # value = <OpType.ecr: 27>
    gphase: ClassVar[OpType]  # value = <OpType.gphase: 1>
    h: ClassVar[OpType]  # value = <OpType.h: 4>
    i: ClassVar[OpType]  # value = <OpType.i: 2>
    iswap: ClassVar[OpType]  # value = <OpType.iswap: 23>
    measure: ClassVar[OpType]  # value = <OpType.measure: 35>
    none: ClassVar[OpType]  # value = <OpType.none: 0>
    peres: ClassVar[OpType]  # value = <OpType.peres: 24>
    peresdag: ClassVar[OpType]  # value = <OpType.peresdag: 25>
    phase: ClassVar[OpType]  # value = <OpType.phase: 16>
    reset: ClassVar[OpType]  # value = <OpType.reset: 36>
    rx: ClassVar[OpType]  # value = <OpType.rx: 19>
    rxx: ClassVar[OpType]  # value = <OpType.rxx: 28>
    ry: ClassVar[OpType]  # value = <OpType.ry: 20>
    ryy: ClassVar[OpType]  # value = <OpType.ryy: 29>
    rz: ClassVar[OpType]  # value = <OpType.rz: 21>
    rzx: ClassVar[OpType]  # value = <OpType.rzx: 31>
    rzz: ClassVar[OpType]  # value = <OpType.rzz: 30>
    s: ClassVar[OpType]  # value = <OpType.s: 8>
    sdag: ClassVar[OpType]  # value = <OpType.sdag: 9>
    swap: ClassVar[OpType]  # value = <OpType.swap: 22>
    sx: ClassVar[OpType]  # value = <OpType.sx: 17>
    sxdag: ClassVar[OpType]  # value = <OpType.sxdag: 18>
    t: ClassVar[OpType]  # value = <OpType.t: 10>
    tdag: ClassVar[OpType]  # value = <OpType.tdag: 11>
    teleportation: ClassVar[OpType]  # value = <OpType.teleportation: 37>
    u2: ClassVar[OpType]  # value = <OpType.u2: 15>
    u3: ClassVar[OpType]  # value = <OpType.u3: 14>
    v: ClassVar[OpType]  # value = <OpType.v: 12>
    vdag: ClassVar[OpType]  # value = <OpType.vdag: 13>
    x: ClassVar[OpType]  # value = <OpType.x: 5>
    xx_minus_yy: ClassVar[OpType]  # value = <OpType.xx_minus_yy: 32>
    xx_plus_yy: ClassVar[OpType]  # value = <OpType.xx_plus_yy: 33>
    y: ClassVar[OpType]  # value = <OpType.y: 6>
    z: ClassVar[OpType]  # value = <OpType.z: 7>
    @property
    def name(self) -> str: ...
    def __eq__(self, other: object) -> bool: ...
    def __getstate__(self) -> int: ...
    def __hash__(self) -> int: ...
    def __index__(self) -> int: ...
    @overload
    def __init__(self, value: int) -> None: ...
    @overload
    def __init__(self, arg0: str) -> None: ...
    def __int__(self) -> int: ...
    def __ne__(self, other: object) -> bool: ...
    def __setstate__(self, state: int) -> None: ...
    @property
    def value(self) -> int: ...

class QuantumComputation:
    gphase: float
    name: str
    def __getitem__(self, arg0: int) -> Operation: ...
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, nq: int) -> None: ...
    @overload
    def __init__(self, filename: str) -> None: ...
    def __len__(self) -> int: ...
    def depth(self) -> int: ...
    def add_ancillary_register(self, n: int, name: str = "") -> None: ...
    def add_classical_bit_register(self, n: int, name: str = "") -> None: ...
    def add_qubit_register(self, n: int, name: str = "") -> None: ...
    def add_variable(self, var: Expression | float) -> None: ...
    def add_variables(self, vars_: list[Expression | float]) -> None: ...
    def append_operation(self, op: Operation) -> None: ...
    @overload
    def barrier(self, q: int) -> None: ...
    @overload
    def barrier(self, qs: list[int]) -> None: ...
    @overload
    def classic_controlled(self, op: OpType, q: int, c: tuple[int, int], t: int, params: list[float]) -> None: ...
    @overload
    def classic_controlled(
        self, op: OpType, q: int, ctrl: Control, c: tuple[int, int], t: int, params: list[float]
    ) -> None: ...
    def clone(self) -> QuantumComputation: ...
    @overload
    def dcx(self, q1: int, q2: int) -> None: ...
    @overload
    def dcx(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def dcx(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def dump(self, filename: str) -> None: ...
    @overload
    def dump(self, filename: str, format_: str) -> None: ...
    @overload
    def ecr(self, q1: int, q2: int) -> None: ...
    @overload
    def ecr(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def ecr(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def from_file(self, filename: str) -> None: ...
    @overload
    def from_file(self, filename: str, format_: str) -> None: ...
    def get_variables(self) -> set[Variable]: ...
    @overload
    def h(self, q: int) -> None: ...
    @overload
    def h(self, q: int, ctrl: Control) -> None: ...
    @overload
    def h(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def i(self, q: int) -> None: ...
    @overload
    def i(self, q: int, ctrl: Control) -> None: ...
    @overload
    def i(self, q: int, controls: set[Control]) -> None: ...
    def initialize_io_mapping(self) -> None: ...
    def instantiate(self, assignment: dict[Variable, float]) -> None: ...
    def is_variable_free(self) -> bool: ...
    @overload
    def iswap(self, q1: int, q2: int) -> None: ...
    @overload
    def iswap(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def iswap(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def measure(self, q: int, c: int) -> None: ...
    @overload
    def measure(self, q: int, c: tuple[str, int]) -> None: ...
    @overload
    def measure(self, qs: list[int], cs: list[int]) -> None: ...
    @overload
    def peres(self, q1: int, q2: int) -> None: ...
    @overload
    def peres(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def peres(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def peresdag(self, q1: int, q2: int) -> None: ...
    @overload
    def peresdag(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def peresdag(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def phase(self, q: int, lambda_: float) -> None: ...
    @overload
    def phase(self, q: int, ctrl: Control, lambda_: float) -> None: ...
    @overload
    def phase(self, q: int, controls: set[Control], lambda_: float) -> None: ...
    @overload
    def reset(self, q: int) -> None: ...
    @overload
    def reset(self, qs: list[int]) -> None: ...
    @overload
    def rx(self, q: int, theta: float) -> None: ...
    @overload
    def rx(self, q: int, ctrl: Control, theta: float) -> None: ...
    @overload
    def rx(self, q: int, controls: set[Control], theta: float) -> None: ...
    @overload
    def rxx(self, q1: int, q2: int, phi: float) -> None: ...
    @overload
    def rxx(self, q1: int, q2: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def rxx(self, q1: int, q2: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def ry(self, q: int, theta: float) -> None: ...
    @overload
    def ry(self, q: int, ctrl: Control, theta: float) -> None: ...
    @overload
    def ry(self, q: int, controls: set[Control], theta: float) -> None: ...
    @overload
    def ryy(self, q1: int, q2: int, phi: float) -> None: ...
    @overload
    def ryy(self, q1: int, q2: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def ryy(self, q1: int, q2: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def rz(self, q: int, phi: float) -> None: ...
    @overload
    def rz(self, q: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def rz(self, q: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def rzx(self, q1: int, q2: int, phi: float) -> None: ...
    @overload
    def rzx(self, q1: int, q2: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def rzx(self, q1: int, q2: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def rzz(self, q1: int, q2: int, phi: float) -> None: ...
    @overload
    def rzz(self, q1: int, q2: int, ctrl: Control, phi: float) -> None: ...
    @overload
    def rzz(self, q1: int, q2: int, controls: set[Control], phi: float) -> None: ...
    @overload
    def s(self, q: int) -> None: ...
    @overload
    def s(self, q: int, ctrl: Control) -> None: ...
    @overload
    def s(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def sdag(self, q: int) -> None: ...
    @overload
    def sdag(self, q: int, ctrl: Control) -> None: ...
    @overload
    def sdag(self, q: int, controls: set[Control]) -> None: ...
    def set_logical_qubit_ancillary(self, q: int) -> None: ...
    @overload
    def swap(self, q1: int, q2: int) -> None: ...
    @overload
    def swap(self, q1: int, q2: int, ctrl: Control) -> None: ...
    @overload
    def swap(self, q1: int, q2: int, controls: set[Control]) -> None: ...
    @overload
    def sx(self, q: int) -> None: ...
    @overload
    def sx(self, q: int, ctrl: Control) -> None: ...
    @overload
    def sx(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def sxdag(self, q: int) -> None: ...
    @overload
    def sxdag(self, q: int, ctrl: Control) -> None: ...
    @overload
    def sxdag(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def t(self, q: int) -> None: ...
    @overload
    def t(self, q: int, ctrl: Control) -> None: ...
    @overload
    def t(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def tdag(self, q: int) -> None: ...
    @overload
    def tdag(self, q: int, ctrl: Control) -> None: ...
    @overload
    def tdag(self, q: int, controls: set[Control]) -> None: ...
    def to_open_qasm(self) -> str: ...
    @overload
    def u2(self, q: int, phi: float, lambda_: float) -> None: ...
    @overload
    def u2(self, q: int, ctrl: Control, phi: float, lambda_: float) -> None: ...
    @overload
    def u2(self, q: int, controls: set[Control], phi: float, lambda_: float) -> None: ...
    @overload
    def u3(self, q: int, theta: float, phi: float, lambda_: float) -> None: ...
    @overload
    def u3(self, q: int, ctrl: Control, theta: float, phi: float, lambda_: float) -> None: ...
    @overload
    def u3(self, q: int, controls: set[Control], theta: float, phi: float, lambda_: float) -> None: ...
    @overload
    def v(self, q: int) -> None: ...
    @overload
    def v(self, q: int, ctrl: Control) -> None: ...
    @overload
    def v(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def vdag(self, q: int) -> None: ...
    @overload
    def vdag(self, q: int, ctrl: Control) -> None: ...
    @overload
    def vdag(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def x(self, q: int) -> None: ...
    @overload
    def x(self, q: int, ctrl: Control) -> None: ...
    @overload
    def x(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def xx_minus_yy(self, q1: int, q2: int, phi: float, lambda_: float) -> None: ...
    @overload
    def xx_minus_yy(self, q1: int, q2: int, ctrl: Control, phi: float, lambda_: float) -> None: ...
    @overload
    def xx_minus_yy(self, q1: int, q2: int, controls: set[Control], phi: float, lambda_: float) -> None: ...
    @overload
    def xx_plus_yy(self, q1: int, q2: int, phi: float, lambda_: float) -> None: ...
    @overload
    def xx_plus_yy(self, q1: int, q2: int, ctrl: Control, phi: float, lambda_: float) -> None: ...
    @overload
    def xx_plus_yy(self, q1: int, q2: int, controls: set[Control], phi: float, lambda_: float) -> None: ...
    @overload
    def y(self, q: int) -> None: ...
    @overload
    def y(self, q: int, ctrl: Control) -> None: ...
    @overload
    def y(self, q: int, controls: set[Control]) -> None: ...
    @overload
    def z(self, q: int) -> None: ...
    @overload
    def z(self, q: int, ctrl: Control) -> None: ...
    @overload
    def z(self, q: int, controls: set[Control]) -> None: ...
    @property
    def initial_layout(self) -> Permutation: ...
    @property
    def n_ancillae(self) -> int: ...
    @property
    def n_cbits(self) -> int: ...
    @property
    def n_individual_ops(self) -> int: ...
    @property
    def n_ops(self) -> int: ...
    @property
    def n_qubits(self) -> int: ...
    @property
    def n_qubits_without_ancillae(self) -> int: ...
    @property
    def n_single_qubit_ops(self) -> int: ...
    @property
    def output_permutation(self) -> Permutation: ...

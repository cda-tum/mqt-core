from abc import ABCMeta, abstractmethod
from collections.abc import Sequence

from ..._compat.typing import Self
from ..permutation import Permutation
from .control import Control
from .optype import OpType

class Operation(metaclass=ABCMeta):
    name: str
    type_: OpType
    controls: set[Control]
    num_qubits: int
    targets: list[int]
    parameter: list[float]
    @property
    def num_targets(self: Self) -> int: ...
    @property
    def num_controls(self: Self) -> int: ...
    @abstractmethod
    def add_control(self: Self, control: Control) -> None: ...
    def add_controls(self: Self, controls: set[Control]) -> None: ...
    @abstractmethod
    def clear_controls(self: Self) -> None: ...
    @abstractmethod
    def remove_control(self: Self, control: Control) -> None: ...
    def remove_controls(self: Self, controls: set[Control]) -> None: ...
    def acts_on(self: Self, qubit: int) -> bool: ...
    def get_used_qubits(self: Self) -> set[int]: ...
    def is_classic_controlled_operation(self: Self) -> bool: ...
    def is_compound_operation(self: Self) -> bool: ...
    def is_controlled(self: Self) -> bool: ...
    def is_non_unitary_operation(self: Self) -> bool: ...
    def is_standard_operation(self: Self) -> bool: ...
    def is_symbolic_operation(self: Self) -> bool: ...
    def is_unitary(self: Self) -> bool: ...
    def get_inverted(self: Self) -> Operation: ...
    @abstractmethod
    def invert(self: Self) -> None: ...
    @abstractmethod
    def qasm_str(self: Self, qreg: Sequence[tuple[str, str]], creg: Sequence[tuple[str, str]]) -> str: ...
    def equals(self: Self, other: Operation, perm1: Permutation, perm2: Permutation) -> bool: ...
    def __eq__(self: Self, other: object) -> bool: ...
